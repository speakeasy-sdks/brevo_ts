/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { z } from "zod";

export type JsonBody = {
    /**
     * List of attributes to be imported
     */
    attributes?: Record<string, any> | undefined;
    email?: string | undefined;
};

/**
 * To create a new list and import the contacts into it, pass the listName and an optional folderId.
 */
export type NewList = {
    /**
     * Id of the folder where this new list shall be created. **Mandatory if listName is not empty**
     *
     * @remarks
     *
     */
    folderId?: number | undefined;
    /**
     * List with listName will be created first and users will be imported in it. **Mandatory if listIds is empty**.
     *
     * @remarks
     *
     */
    listName?: string | undefined;
};

export type RequestContactImport = {
    /**
     * To blacklist all the contacts for email
     */
    emailBlacklist?: boolean | undefined;
    /**
     * To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes = true means the empty fields in your import will erase any attribute that currently contain data in Brevo, & emptyContactsAttributes = false means the empty fields will not affect your existing data ( **only available if `updateExistingContacts` set to true **)
     *
     * @remarks
     *
     */
    emptyContactsAttributes?: boolean | undefined;
    /**
     * **Mandatory if fileUrl and jsonBody is not defined.** CSV content to be imported. Use semicolon to separate multiple attributes. **Maximum allowed file body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of file body size while parsing. Please use fileUrl instead to import bigger files.
     *
     * @remarks
     *
     */
    fileBody?: string | undefined;
    /**
     * **Mandatory if fileBody and jsonBody is not defined.** URL of the file to be imported (**no local file**). Possible file formats:
     *
     * @remarks
     * #### .txt, .csv, .json
     *
     */
    fileUrl?: string | undefined;
    /**
     * **Mandatory if fileUrl and fileBody is not defined.** JSON content to be imported. **Maximum allowed json body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of json body size while parsing. Please use fileUrl instead to import bigger files.
     *
     * @remarks
     *
     */
    jsonBody?: Array<JsonBody> | undefined;
    /**
     * **Mandatory if newList is not defined.** Ids of the lists in which the contacts shall be imported. For example, **[2, 4, 7]**.
     *
     * @remarks
     *
     */
    listIds?: Array<number> | undefined;
    /**
     * To create a new list and import the contacts into it, pass the listName and an optional folderId.
     */
    newList?: NewList | undefined;
    /**
     * URL that will be called once the import process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479
     */
    notifyUrl?: string | undefined;
    /**
     * To blacklist all the contacts for sms
     */
    smsBlacklist?: boolean | undefined;
    /**
     * To facilitate the choice to update the existing contacts
     */
    updateExistingContacts?: boolean | undefined;
};

/** @internal */
export namespace JsonBody$ {
    export type Inbound = {
        attributes?: Record<string, any> | undefined;
        email?: string | undefined;
    };

    export const inboundSchema: z.ZodType<JsonBody, z.ZodTypeDef, Inbound> = z
        .object({
            attributes: z.record(z.any()).optional(),
            email: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.attributes === undefined ? null : { attributes: v.attributes }),
                ...(v.email === undefined ? null : { email: v.email }),
            };
        });

    export type Outbound = {
        attributes?: Record<string, any> | undefined;
        email?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, JsonBody> = z
        .object({
            attributes: z.record(z.any()).optional(),
            email: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.attributes === undefined ? null : { attributes: v.attributes }),
                ...(v.email === undefined ? null : { email: v.email }),
            };
        });
}

/** @internal */
export namespace NewList$ {
    export type Inbound = {
        folderId?: number | undefined;
        listName?: string | undefined;
    };

    export const inboundSchema: z.ZodType<NewList, z.ZodTypeDef, Inbound> = z
        .object({
            folderId: z.number().int().optional(),
            listName: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.folderId === undefined ? null : { folderId: v.folderId }),
                ...(v.listName === undefined ? null : { listName: v.listName }),
            };
        });

    export type Outbound = {
        folderId?: number | undefined;
        listName?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, NewList> = z
        .object({
            folderId: z.number().int().optional(),
            listName: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.folderId === undefined ? null : { folderId: v.folderId }),
                ...(v.listName === undefined ? null : { listName: v.listName }),
            };
        });
}

/** @internal */
export namespace RequestContactImport$ {
    export type Inbound = {
        emailBlacklist?: boolean | undefined;
        emptyContactsAttributes?: boolean | undefined;
        fileBody?: string | undefined;
        fileUrl?: string | undefined;
        jsonBody?: Array<JsonBody$.Inbound> | undefined;
        listIds?: Array<number> | undefined;
        newList?: NewList$.Inbound | undefined;
        notifyUrl?: string | undefined;
        smsBlacklist?: boolean | undefined;
        updateExistingContacts?: boolean | undefined;
    };

    export const inboundSchema: z.ZodType<RequestContactImport, z.ZodTypeDef, Inbound> = z
        .object({
            emailBlacklist: z.boolean().default(false),
            emptyContactsAttributes: z.boolean().default(false),
            fileBody: z.string().optional(),
            fileUrl: z.string().optional(),
            jsonBody: z.array(z.lazy(() => JsonBody$.inboundSchema)).optional(),
            listIds: z.array(z.number().int()).optional(),
            newList: z.lazy(() => NewList$.inboundSchema).optional(),
            notifyUrl: z.string().optional(),
            smsBlacklist: z.boolean().default(false),
            updateExistingContacts: z.boolean().default(true),
        })
        .transform((v) => {
            return {
                ...(v.emailBlacklist === undefined ? null : { emailBlacklist: v.emailBlacklist }),
                ...(v.emptyContactsAttributes === undefined
                    ? null
                    : { emptyContactsAttributes: v.emptyContactsAttributes }),
                ...(v.fileBody === undefined ? null : { fileBody: v.fileBody }),
                ...(v.fileUrl === undefined ? null : { fileUrl: v.fileUrl }),
                ...(v.jsonBody === undefined ? null : { jsonBody: v.jsonBody }),
                ...(v.listIds === undefined ? null : { listIds: v.listIds }),
                ...(v.newList === undefined ? null : { newList: v.newList }),
                ...(v.notifyUrl === undefined ? null : { notifyUrl: v.notifyUrl }),
                ...(v.smsBlacklist === undefined ? null : { smsBlacklist: v.smsBlacklist }),
                ...(v.updateExistingContacts === undefined
                    ? null
                    : { updateExistingContacts: v.updateExistingContacts }),
            };
        });

    export type Outbound = {
        emailBlacklist: boolean;
        emptyContactsAttributes: boolean;
        fileBody?: string | undefined;
        fileUrl?: string | undefined;
        jsonBody?: Array<JsonBody$.Outbound> | undefined;
        listIds?: Array<number> | undefined;
        newList?: NewList$.Outbound | undefined;
        notifyUrl?: string | undefined;
        smsBlacklist: boolean;
        updateExistingContacts: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, RequestContactImport> = z
        .object({
            emailBlacklist: z.boolean().default(false),
            emptyContactsAttributes: z.boolean().default(false),
            fileBody: z.string().optional(),
            fileUrl: z.string().optional(),
            jsonBody: z.array(z.lazy(() => JsonBody$.outboundSchema)).optional(),
            listIds: z.array(z.number().int()).optional(),
            newList: z.lazy(() => NewList$.outboundSchema).optional(),
            notifyUrl: z.string().optional(),
            smsBlacklist: z.boolean().default(false),
            updateExistingContacts: z.boolean().default(true),
        })
        .transform((v) => {
            return {
                emailBlacklist: v.emailBlacklist,
                emptyContactsAttributes: v.emptyContactsAttributes,
                ...(v.fileBody === undefined ? null : { fileBody: v.fileBody }),
                ...(v.fileUrl === undefined ? null : { fileUrl: v.fileUrl }),
                ...(v.jsonBody === undefined ? null : { jsonBody: v.jsonBody }),
                ...(v.listIds === undefined ? null : { listIds: v.listIds }),
                ...(v.newList === undefined ? null : { newList: v.newList }),
                ...(v.notifyUrl === undefined ? null : { notifyUrl: v.notifyUrl }),
                smsBlacklist: v.smsBlacklist,
                updateExistingContacts: v.updateExistingContacts,
            };
        });
}
