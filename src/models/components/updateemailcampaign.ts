/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { z } from "zod";

/**
 * Segment ids and List ids to include/exclude from campaign
 */
export type UpdateEmailCampaignRecipients = {
    /**
     * List ids which have to be excluded from a campaign
     */
    exclusionListIds?: Array<number> | undefined;
    /**
     * Lists Ids to send the campaign to. **Campaign should only be updated with listIds if listIds were used to create it. REQUIRED if already not present in campaign and scheduledAt is not empty**
     *
     * @remarks
     *
     */
    listIds?: Array<number> | undefined;
    /**
     * **Mandatory if listIds are not used. Campaign should only be updated with segmentIds if segmentIds were used to create it.** Segment ids to send the campaign to.
     *
     * @remarks
     *
     */
    segmentIds?: Array<number> | undefined;
};

/**
 * Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example:
 *
 * @remarks
 * **{"name":"xyz", "email":"example@abc.com"}**
 * **{"name":"xyz", "id":123}**
 *
 */
export type UpdateEmailCampaignSender = {
    /**
     * Sender email from which the campaign emails are sent
     */
    email?: string | undefined;
    /**
     * Select the sender for the campaign on the basis of sender id. **In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email)**.
     *
     * @remarks
     *
     */
    id?: number | undefined;
    /**
     * Sender Name from which the campaign emails are sent
     */
    name?: string | undefined;
};

/**
 * Choose the metrics that will determinate the winning version. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerCriteria` is ignored if passed
 *
 * @remarks
 *
 */
export enum UpdateEmailCampaignWinnerCriteria {
    Open = "open",
    Click = "click",
}

export type UpdateEmailCampaign = {
    /**
     * Status of A/B Test. abTesting = false means it is disabled & abTesting = true means it is enabled. **subjectA, subjectB, splitRule, winnerCriteria & winnerDelay** will be considered when abTesting is set to true.
     *
     * @remarks
     * subjectA & subjectB are mandatory together & subject if passed is ignored. **Can be set to true only if sendAtBestTime is false**.
     * You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
     *
     */
    abTesting?: boolean | undefined;
    /**
     * Absolute url of the attachment (no local file).
     *
     * @remarks
     * Extension allowed:
     * #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'
     *
     */
    attachmentUrl?: string | undefined;
    /**
     * Footer of the email campaign
     */
    footer?: string | undefined;
    /**
     * Header of the email campaign
     */
    header?: string | undefined;
    /**
     * Body of the message (HTML version). If the campaign is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that campaign. **REQUIRED if htmlUrl is empty**
     *
     * @remarks
     *
     */
    htmlContent?: string | undefined;
    /**
     * Url which contents the body of the email message. **REQUIRED if htmlContent is empty**
     *
     * @remarks
     *
     */
    htmlUrl?: string | undefined;
    /**
     * Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
     *
     * @remarks
     *
     */
    increaseRate?: number | undefined;
    /**
     * Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
     *
     * @remarks
     *
     */
    initialQuota?: number | undefined;
    /**
     * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email.
     *
     * @remarks
     * You cannot send a campaign of more than **4MB** with images embedded in the email. Campaigns with the images embedded in the email _must be sent to less than 5000 contacts_.
     *
     */
    inlineImageActivation?: boolean | undefined;
    /**
     * **Available for dedicated ip clients**. Set this to true if you wish to warm up your ip.
     *
     * @remarks
     *
     */
    ipWarmupEnable?: boolean | undefined;
    /**
     * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
     */
    mirrorActive?: boolean | undefined;
    /**
     * Name of the campaign
     */
    name?: string | undefined;
    /**
     * Pass the set of attributes to customize the type classic campaign. For example: **{"FNAME":"Joe", "LNAME":"Doe"}**. Only available if **type** is **classic**. It's considered only if campaign is in _New Template Language format_. The New Template Language is dependent on the values of **subject, htmlContent/htmlUrl, sender.name & toField**
     *
     * @remarks
     *
     */
    params?: Record<string, any> | undefined;
    /**
     * Preview text or preheader of the email campaign
     */
    previewText?: string | undefined;
    /**
     * Segment ids and List ids to include/exclude from campaign
     */
    recipients?: UpdateEmailCampaignRecipients | undefined;
    /**
     * **FOR TRIGGER ONLY !** Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
     *
     * @remarks
     *
     */
    recurring?: boolean | undefined;
    /**
     * Email on which campaign recipients will be able to reply to
     */
    replyTo?: string | undefined;
    /**
     * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ).
     *
     * @remarks
     * **Prefer to pass your timezone in date-time format for accurate result.**
     * If sendAtBestTime is set to true, your campaign will be sent according
     * to the date passed (ignoring the time part).
     *
     */
    scheduledAt?: string | undefined;
    /**
     * Set this to true if you want to send your campaign at best time.
     *
     * @remarks
     * Note:- **if true, warmup ip will be disabled.**
     *
     */
    sendAtBestTime?: boolean | undefined;
    /**
     * Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example:
     *
     * @remarks
     * **{"name":"xyz", "email":"example@abc.com"}**
     * **{"name":"xyz", "id":123}**
     *
     */
    sender?: UpdateEmailCampaignSender | undefined;
    /**
     * Add the size of your test groups. **Mandatory if abTesting = true & 'recipients' is passed**. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
     *
     * @remarks
     *
     */
    splitRule?: number | undefined;
    /**
     * Subject of the campaign
     */
    subject?: string | undefined;
    /**
     * Subject A of the campaign. **Mandatory if abTesting = true**.
     *
     * @remarks
     * subjectA & subjectB should have unique value
     *
     */
    subjectA?: string | undefined;
    /**
     * Subject B of the campaign. **Mandatory if abTesting = true**.
     *
     * @remarks
     * subjectA & subjectB should have unique value
     *
     */
    subjectB?: string | undefined;
    /**
     * Tag of the campaign
     */
    tag?: string | undefined;
    /**
     * To personalize the **To** Field. If you want to include the first
     *
     * @remarks
     * name and last name of your recipient, add **{FNAME} {LNAME}**. These contact
     * attributes must already exist in your Brevo account. If input parameter
     * **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization
     *
     */
    toField?: string | undefined;
    /**
     * Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page.
     *
     * @remarks
     *
     */
    unsubscriptionPageId?: string | undefined;
    /**
     * **Mandatory if templateId is used containing the {{ update_profile }} tag**. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form.
     *
     * @remarks
     *
     */
    updateFormId?: string | undefined;
    /**
     * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
     */
    utmCampaign?: string | undefined;
    /**
     * Choose the metrics that will determinate the winning version. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerCriteria` is ignored if passed
     *
     * @remarks
     *
     */
    winnerCriteria?: UpdateEmailCampaignWinnerCriteria | undefined;
    /**
     * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerDelay` is ignored if passed
     *
     * @remarks
     *
     */
    winnerDelay?: number | undefined;
};

/** @internal */
export namespace UpdateEmailCampaignRecipients$ {
    export type Inbound = {
        exclusionListIds?: Array<number> | undefined;
        listIds?: Array<number> | undefined;
        segmentIds?: Array<number> | undefined;
    };

    export const inboundSchema: z.ZodType<UpdateEmailCampaignRecipients, z.ZodTypeDef, Inbound> = z
        .object({
            exclusionListIds: z.array(z.number().int()).optional(),
            listIds: z.array(z.number().int()).optional(),
            segmentIds: z.array(z.number().int()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.exclusionListIds === undefined
                    ? null
                    : { exclusionListIds: v.exclusionListIds }),
                ...(v.listIds === undefined ? null : { listIds: v.listIds }),
                ...(v.segmentIds === undefined ? null : { segmentIds: v.segmentIds }),
            };
        });

    export type Outbound = {
        exclusionListIds?: Array<number> | undefined;
        listIds?: Array<number> | undefined;
        segmentIds?: Array<number> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateEmailCampaignRecipients> =
        z
            .object({
                exclusionListIds: z.array(z.number().int()).optional(),
                listIds: z.array(z.number().int()).optional(),
                segmentIds: z.array(z.number().int()).optional(),
            })
            .transform((v) => {
                return {
                    ...(v.exclusionListIds === undefined
                        ? null
                        : { exclusionListIds: v.exclusionListIds }),
                    ...(v.listIds === undefined ? null : { listIds: v.listIds }),
                    ...(v.segmentIds === undefined ? null : { segmentIds: v.segmentIds }),
                };
            });
}

/** @internal */
export namespace UpdateEmailCampaignSender$ {
    export type Inbound = {
        email?: string | undefined;
        id?: number | undefined;
        name?: string | undefined;
    };

    export const inboundSchema: z.ZodType<UpdateEmailCampaignSender, z.ZodTypeDef, Inbound> = z
        .object({
            email: z.string().optional(),
            id: z.number().int().optional(),
            name: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.email === undefined ? null : { email: v.email }),
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.name === undefined ? null : { name: v.name }),
            };
        });

    export type Outbound = {
        email?: string | undefined;
        id?: number | undefined;
        name?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateEmailCampaignSender> = z
        .object({
            email: z.string().optional(),
            id: z.number().int().optional(),
            name: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.email === undefined ? null : { email: v.email }),
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.name === undefined ? null : { name: v.name }),
            };
        });
}

/** @internal */
export const UpdateEmailCampaignWinnerCriteria$ = z.nativeEnum(UpdateEmailCampaignWinnerCriteria);

/** @internal */
export namespace UpdateEmailCampaign$ {
    export type Inbound = {
        abTesting?: boolean | undefined;
        attachmentUrl?: string | undefined;
        footer?: string | undefined;
        header?: string | undefined;
        htmlContent?: string | undefined;
        htmlUrl?: string | undefined;
        increaseRate?: number | undefined;
        initialQuota?: number | undefined;
        inlineImageActivation?: boolean | undefined;
        ipWarmupEnable?: boolean | undefined;
        mirrorActive?: boolean | undefined;
        name?: string | undefined;
        params?: Record<string, any> | undefined;
        previewText?: string | undefined;
        recipients?: UpdateEmailCampaignRecipients$.Inbound | undefined;
        recurring?: boolean | undefined;
        replyTo?: string | undefined;
        scheduledAt?: string | undefined;
        sendAtBestTime?: boolean | undefined;
        sender?: UpdateEmailCampaignSender$.Inbound | undefined;
        splitRule?: number | undefined;
        subject?: string | undefined;
        subjectA?: string | undefined;
        subjectB?: string | undefined;
        tag?: string | undefined;
        toField?: string | undefined;
        unsubscriptionPageId?: string | undefined;
        updateFormId?: string | undefined;
        utmCampaign?: string | undefined;
        winnerCriteria?: UpdateEmailCampaignWinnerCriteria | undefined;
        winnerDelay?: number | undefined;
    };

    export const inboundSchema: z.ZodType<UpdateEmailCampaign, z.ZodTypeDef, Inbound> = z
        .object({
            abTesting: z.boolean().optional(),
            attachmentUrl: z.string().optional(),
            footer: z.string().optional(),
            header: z.string().optional(),
            htmlContent: z.string().optional(),
            htmlUrl: z.string().optional(),
            increaseRate: z.number().int().optional(),
            initialQuota: z.number().int().optional(),
            inlineImageActivation: z.boolean().optional(),
            ipWarmupEnable: z.boolean().optional(),
            mirrorActive: z.boolean().optional(),
            name: z.string().optional(),
            params: z.record(z.any()).optional(),
            previewText: z.string().optional(),
            recipients: z.lazy(() => UpdateEmailCampaignRecipients$.inboundSchema).optional(),
            recurring: z.boolean().optional(),
            replyTo: z.string().optional(),
            scheduledAt: z.string().optional(),
            sendAtBestTime: z.boolean().optional(),
            sender: z.lazy(() => UpdateEmailCampaignSender$.inboundSchema).optional(),
            splitRule: z.number().int().optional(),
            subject: z.string().optional(),
            subjectA: z.string().optional(),
            subjectB: z.string().optional(),
            tag: z.string().optional(),
            toField: z.string().optional(),
            unsubscriptionPageId: z.string().optional(),
            updateFormId: z.string().optional(),
            utmCampaign: z.string().optional(),
            winnerCriteria: UpdateEmailCampaignWinnerCriteria$.optional(),
            winnerDelay: z.number().int().optional(),
        })
        .transform((v) => {
            return {
                ...(v.abTesting === undefined ? null : { abTesting: v.abTesting }),
                ...(v.attachmentUrl === undefined ? null : { attachmentUrl: v.attachmentUrl }),
                ...(v.footer === undefined ? null : { footer: v.footer }),
                ...(v.header === undefined ? null : { header: v.header }),
                ...(v.htmlContent === undefined ? null : { htmlContent: v.htmlContent }),
                ...(v.htmlUrl === undefined ? null : { htmlUrl: v.htmlUrl }),
                ...(v.increaseRate === undefined ? null : { increaseRate: v.increaseRate }),
                ...(v.initialQuota === undefined ? null : { initialQuota: v.initialQuota }),
                ...(v.inlineImageActivation === undefined
                    ? null
                    : { inlineImageActivation: v.inlineImageActivation }),
                ...(v.ipWarmupEnable === undefined ? null : { ipWarmupEnable: v.ipWarmupEnable }),
                ...(v.mirrorActive === undefined ? null : { mirrorActive: v.mirrorActive }),
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.params === undefined ? null : { params: v.params }),
                ...(v.previewText === undefined ? null : { previewText: v.previewText }),
                ...(v.recipients === undefined ? null : { recipients: v.recipients }),
                ...(v.recurring === undefined ? null : { recurring: v.recurring }),
                ...(v.replyTo === undefined ? null : { replyTo: v.replyTo }),
                ...(v.scheduledAt === undefined ? null : { scheduledAt: v.scheduledAt }),
                ...(v.sendAtBestTime === undefined ? null : { sendAtBestTime: v.sendAtBestTime }),
                ...(v.sender === undefined ? null : { sender: v.sender }),
                ...(v.splitRule === undefined ? null : { splitRule: v.splitRule }),
                ...(v.subject === undefined ? null : { subject: v.subject }),
                ...(v.subjectA === undefined ? null : { subjectA: v.subjectA }),
                ...(v.subjectB === undefined ? null : { subjectB: v.subjectB }),
                ...(v.tag === undefined ? null : { tag: v.tag }),
                ...(v.toField === undefined ? null : { toField: v.toField }),
                ...(v.unsubscriptionPageId === undefined
                    ? null
                    : { unsubscriptionPageId: v.unsubscriptionPageId }),
                ...(v.updateFormId === undefined ? null : { updateFormId: v.updateFormId }),
                ...(v.utmCampaign === undefined ? null : { utmCampaign: v.utmCampaign }),
                ...(v.winnerCriteria === undefined ? null : { winnerCriteria: v.winnerCriteria }),
                ...(v.winnerDelay === undefined ? null : { winnerDelay: v.winnerDelay }),
            };
        });

    export type Outbound = {
        abTesting?: boolean | undefined;
        attachmentUrl?: string | undefined;
        footer?: string | undefined;
        header?: string | undefined;
        htmlContent?: string | undefined;
        htmlUrl?: string | undefined;
        increaseRate?: number | undefined;
        initialQuota?: number | undefined;
        inlineImageActivation?: boolean | undefined;
        ipWarmupEnable?: boolean | undefined;
        mirrorActive?: boolean | undefined;
        name?: string | undefined;
        params?: Record<string, any> | undefined;
        previewText?: string | undefined;
        recipients?: UpdateEmailCampaignRecipients$.Outbound | undefined;
        recurring?: boolean | undefined;
        replyTo?: string | undefined;
        scheduledAt?: string | undefined;
        sendAtBestTime?: boolean | undefined;
        sender?: UpdateEmailCampaignSender$.Outbound | undefined;
        splitRule?: number | undefined;
        subject?: string | undefined;
        subjectA?: string | undefined;
        subjectB?: string | undefined;
        tag?: string | undefined;
        toField?: string | undefined;
        unsubscriptionPageId?: string | undefined;
        updateFormId?: string | undefined;
        utmCampaign?: string | undefined;
        winnerCriteria?: UpdateEmailCampaignWinnerCriteria | undefined;
        winnerDelay?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateEmailCampaign> = z
        .object({
            abTesting: z.boolean().optional(),
            attachmentUrl: z.string().optional(),
            footer: z.string().optional(),
            header: z.string().optional(),
            htmlContent: z.string().optional(),
            htmlUrl: z.string().optional(),
            increaseRate: z.number().int().optional(),
            initialQuota: z.number().int().optional(),
            inlineImageActivation: z.boolean().optional(),
            ipWarmupEnable: z.boolean().optional(),
            mirrorActive: z.boolean().optional(),
            name: z.string().optional(),
            params: z.record(z.any()).optional(),
            previewText: z.string().optional(),
            recipients: z.lazy(() => UpdateEmailCampaignRecipients$.outboundSchema).optional(),
            recurring: z.boolean().optional(),
            replyTo: z.string().optional(),
            scheduledAt: z.string().optional(),
            sendAtBestTime: z.boolean().optional(),
            sender: z.lazy(() => UpdateEmailCampaignSender$.outboundSchema).optional(),
            splitRule: z.number().int().optional(),
            subject: z.string().optional(),
            subjectA: z.string().optional(),
            subjectB: z.string().optional(),
            tag: z.string().optional(),
            toField: z.string().optional(),
            unsubscriptionPageId: z.string().optional(),
            updateFormId: z.string().optional(),
            utmCampaign: z.string().optional(),
            winnerCriteria: UpdateEmailCampaignWinnerCriteria$.optional(),
            winnerDelay: z.number().int().optional(),
        })
        .transform((v) => {
            return {
                ...(v.abTesting === undefined ? null : { abTesting: v.abTesting }),
                ...(v.attachmentUrl === undefined ? null : { attachmentUrl: v.attachmentUrl }),
                ...(v.footer === undefined ? null : { footer: v.footer }),
                ...(v.header === undefined ? null : { header: v.header }),
                ...(v.htmlContent === undefined ? null : { htmlContent: v.htmlContent }),
                ...(v.htmlUrl === undefined ? null : { htmlUrl: v.htmlUrl }),
                ...(v.increaseRate === undefined ? null : { increaseRate: v.increaseRate }),
                ...(v.initialQuota === undefined ? null : { initialQuota: v.initialQuota }),
                ...(v.inlineImageActivation === undefined
                    ? null
                    : { inlineImageActivation: v.inlineImageActivation }),
                ...(v.ipWarmupEnable === undefined ? null : { ipWarmupEnable: v.ipWarmupEnable }),
                ...(v.mirrorActive === undefined ? null : { mirrorActive: v.mirrorActive }),
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.params === undefined ? null : { params: v.params }),
                ...(v.previewText === undefined ? null : { previewText: v.previewText }),
                ...(v.recipients === undefined ? null : { recipients: v.recipients }),
                ...(v.recurring === undefined ? null : { recurring: v.recurring }),
                ...(v.replyTo === undefined ? null : { replyTo: v.replyTo }),
                ...(v.scheduledAt === undefined ? null : { scheduledAt: v.scheduledAt }),
                ...(v.sendAtBestTime === undefined ? null : { sendAtBestTime: v.sendAtBestTime }),
                ...(v.sender === undefined ? null : { sender: v.sender }),
                ...(v.splitRule === undefined ? null : { splitRule: v.splitRule }),
                ...(v.subject === undefined ? null : { subject: v.subject }),
                ...(v.subjectA === undefined ? null : { subjectA: v.subjectA }),
                ...(v.subjectB === undefined ? null : { subjectB: v.subjectB }),
                ...(v.tag === undefined ? null : { tag: v.tag }),
                ...(v.toField === undefined ? null : { toField: v.toField }),
                ...(v.unsubscriptionPageId === undefined
                    ? null
                    : { unsubscriptionPageId: v.unsubscriptionPageId }),
                ...(v.updateFormId === undefined ? null : { updateFormId: v.updateFormId }),
                ...(v.utmCampaign === undefined ? null : { utmCampaign: v.utmCampaign }),
                ...(v.winnerCriteria === undefined ? null : { winnerCriteria: v.winnerCriteria }),
                ...(v.winnerDelay === undefined ? null : { winnerDelay: v.winnerDelay }),
            };
        });
}
